{"version":3,"file":"formatter.js","sourceRoot":"","sources":["formatter.ts"],"names":[],"mappings":";;AAAA,+BAAiC;AACjC,iCAA0D;AAE1D,iHAAiH;AAEjH,iGAAiG;AACjG,kGAAkG;AAClG,gBAA+B,QAAgB,EAAE,IAAY,EAAE,OAA2C;IAA3C,wBAAA,EAAA,UAAU,uCAA+B,EAAE;IAEtG,wBAAwB;IACxB,IAAI,UAAU,GAAG,EAAE,CAAC,gBAAgB,CAAC,QAAQ,EAAE,IAAI,EAAE,EAAE,CAAC,YAAY,CAAC,MAAM,EAAE,IAAI,CAAC,CAAC;IAEnF,gDAAgD;IAChD,IAAI,KAAK,GAAI,EAAU,CAAC,UAAU,CAAC,cAAc,CAAC,UAAU,EAAE,eAAe,CAAC,OAAO,CAAC,EAAE,OAAO,CAAC,CAAC;IAEjG,oCAAoC;IACpC,MAAM,CAAC,UAAU,CAAC,IAAI,EAAE,KAAK,CAAC,CAAC;IAE/B,yBAAyB,QAA+B;QACpD,iEAAiE;QACjE,4DAA4D;QAC5D,IAAI,YAAY,GAAG,IAAK,EAAU,CAAC,UAAU,CAAC,aAAa,EAAE,CAAC;QAC9D,YAAY,CAAC,cAAc,CAAC,QAAQ,CAAC,CAAC;QACtC,MAAM,CAAC,YAAY,CAAC;IACxB,CAAC;IAED,oBAAoB,IAAY,EAAE,KAAsB;QACpD,8CAA8C;QAC9C,IAAI,MAAM,GAAG,IAAI,CAAC;QAElB,+DAA+D;QAC/D,qEAAqE;QACrE,iEAAiE;QACjE,+DAA+D;QAC/D,oBAAoB;QAEpB,4DAA4D;QAC5D,KAAK,CAAC,IAAI,CAAC,UAAC,CAAC,EAAE,CAAC,IAAK,OAAA,CAAC,CAAC,IAAI,CAAC,KAAK,GAAG,CAAC,CAAC,IAAI,CAAC,KAAK,EAA3B,CAA2B,CAAC,CAAC;QAClD,GAAG,CAAC,CAAC,IAAI,CAAC,GAAG,KAAK,CAAC,MAAM,GAAG,CAAC,EAAE,CAAC,IAAI,CAAC,EAAE,CAAC,EAAE,EAAE,CAAC;YACzC,IAAI,MAAM,GAAG,KAAK,CAAC,CAAC,CAAC,CAAC;YACtB,IAAI,IAAI,GAAG,MAAM,CAAC,KAAK,CAAC,CAAC,EAAE,MAAM,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;YAC9C,IAAI,IAAI,GAAG,MAAM,CAAC,KAAK,CAAC,MAAM,CAAC,IAAI,CAAC,KAAK,GAAG,MAAM,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;YAChE,MAAM,GAAG,IAAI,GAAG,MAAM,CAAC,OAAO,GAAG,IAAI,CAAC;QAC1C,CAAC;QACD,MAAM,CAAC,MAAM,CAAC;IAClB,CAAC;AACL,CAAC;AAvCD,yBAuCC","sourcesContent":["import * as ts from \"typescript\";\nimport { createDefaultFormatCodeSettings } from \"./utils\";\n\n// from https://github.com/Microsoft/TypeScript/wiki/Using-the-Compiler-API#pretty-printer-using-the-ls-formatter\n\n// Note: this uses ts.formatting which is part of the typescript 1.4 package but is not currently\n//       exposed in the public typescript.d.ts. The typings should be exposed in the next release.\nexport default function format(fileName: string, text: string, options = createDefaultFormatCodeSettings()) {\n\n    // Parse the source text\n    let sourceFile = ts.createSourceFile(fileName, text, ts.ScriptTarget.Latest, true);\n\n    // Get the formatting edits on the input sources\n    let edits = (ts as any).formatting.formatDocument(sourceFile, getRuleProvider(options), options);\n\n    // Apply the edits on the input code\n    return applyEdits(text, edits);\n\n    function getRuleProvider(settings: ts.FormatCodeSettings) {\n        // Share this between multiple formatters using the same options.\n        // This represents the bulk of the space the formatter uses.\n        let ruleProvider = new (ts as any).formatting.RulesProvider();\n        ruleProvider.ensureUpToDate(settings);\n        return ruleProvider;\n    }\n\n    function applyEdits(text: string, edits: ts.TextChange[]): string {\n        // Apply edits in reverse on the existing text\n        let result = text;\n\n        // An issue with `ts.formatting.formatDocument` is that it does\n        // not always give the edits array in ascending order of change start\n        // point. This can result that we add or remove some character in\n        // the begining of the document, making the all the other edits\n        // offsets invalid. \n\n        // We resolve this by sorting edits by ascending start point\n        edits.sort((a, b) => a.span.start - b.span.start);\n        for (let i = edits.length - 1; i >= 0; i--) {\n            let change = edits[i];\n            let head = result.slice(0, change.span.start);\n            let tail = result.slice(change.span.start + change.span.length);\n            result = head + change.newText + tail;\n        }\n        return result;\n    }\n}\n"]}