"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var ts = require("typescript");
var utils_1 = require("./utils");
// from https://github.com/Microsoft/TypeScript/wiki/Using-the-Compiler-API#pretty-printer-using-the-ls-formatter
// Note: this uses ts.formatting which is part of the typescript 1.4 package but is not currently
//       exposed in the public typescript.d.ts. The typings should be exposed in the next release.
function format(fileName, text, options) {
    if (options === void 0) { options = utils_1.createDefaultFormatCodeSettings(); }
    // Parse the source text
    var sourceFile = ts.createSourceFile(fileName, text, ts.ScriptTarget.Latest, true);
    // Get the formatting edits on the input sources
    var edits = ts.formatting.formatDocument(sourceFile, getRuleProvider(options), options);
    // Apply the edits on the input code
    return applyEdits(text, edits);
    function getRuleProvider(settings) {
        // Share this between multiple formatters using the same options.
        // This represents the bulk of the space the formatter uses.
        var ruleProvider = new ts.formatting.RulesProvider();
        ruleProvider.ensureUpToDate(settings);
        return ruleProvider;
    }
    function applyEdits(text, edits) {
        // Apply edits in reverse on the existing text
        var result = text;
        // An issue with `ts.formatting.formatDocument` is that it does
        // not always give the edits array in ascending order of change start
        // point. This can result that we add or remove some character in
        // the begining of the document, making the all the other edits
        // offsets invalid. 
        // We resolve this by sorting edits by ascending start point
        edits.sort(function (a, b) { return a.span.start - b.span.start; });
        for (var i = edits.length - 1; i >= 0; i--) {
            var change = edits[i];
            var head = result.slice(0, change.span.start);
            var tail = result.slice(change.span.start + change.span.length);
            result = head + change.newText + tail;
        }
        return result;
    }
}
exports.default = format;
//# sourceMappingURL=formatter.js.map